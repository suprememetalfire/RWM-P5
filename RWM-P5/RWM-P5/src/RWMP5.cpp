/*
-----------------------------------------------------------------------------
Filename:    RWMP5.cpp
-----------------------------------------------------------------------------


This source file is generated by the
   ___                   _              __    __ _                  _ 
      http://code.google.com/p/ogreappwizards/
-----------------------------------------------------------------------------
*/
/*  /___\__ _ _ __ ___    /_\  _ __  _ __/ / /\ \ (_)______ _ _ __ __| |
 //  // _` | '__/ _ \  //_\\| '_ \| '_ \ \/  \/ / |_  / _` | '__/ _` |
/ \_// (_| | | |  __/ /  _  \ |_) | |_) \  /\  /| |/ / (_| | | | (_| |
\___/ \__, |_|  \___| \_/ \_/ .__/| .__/ \/  \/ |_/___\__,_|_|  \__,_|
      |___/                 |_|   |_|                                 
      Ogre 1.7.x Application Wizard for VC10 (July 2011)*/

#include "RWMP5.h"

//-------------------------------------------------------------------------------------
RWMP5::RWMP5(void)
	:m_mouseLeftDown(false),m_currentBirdBody(NULL),m_bomberBird(NULL),m_assaultBird(NULL),
	m_ghostBird(NULL),m_momBird(NULL)
{
}
//-------------------------------------------------------------------------------------
RWMP5::~RWMP5(void)
{
	mSceneMgr->destroyQuery(mRayScnQuery);
	m_physics->TidyUp();
}

//-------------------------------------------------------------------------------------
void RWMP5::createScene(void)
{
   ////////////////////////////////////////////////////////////////////////////////////////////////////////
	//										Ogre3D Initialisation										  //
	////////////////////////////////////////////////////////////////////////////////////////////////////////

	mSceneMgr->setSkyBox(true, "Examples/SpaceSkyBox");

	// Set ambient light
	mSceneMgr->setAmbientLight(Ogre::ColourValue(0.5, 0.5, 0.5));

	// Create a light
	Ogre::Light* l = mSceneMgr->createLight("MainLight");
	l->setPosition(20,80,50);


	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//										Havok Initialisation										  //
	////////////////////////////////////////////////////////////////////////////////////////////////////////

	m_physics = Physics::getInstance();
	m_physics->SetUp();

	//Collision Filtering Initialisation						
	filter = new hkpPairCollisionFilter();	
	m_physics->GetPhysicsWorld()->setCollisionFilter( filter );
	filter->removeReference();

	// create floor plane/box
	hkVector4 groundBox( 499.0f, 2.0f, 499.0f );
	hkVector4 position( 0.0f, 0.0f, 0.0f );
	hkpConvexShape* shape = new hkpBoxShape( groundBox , 0 );

	hkpRigidBodyCinfo ci; //rigidbody class info; sets properties of rigid body

	ci.m_shape = shape;
	ci.m_motionType = hkpMotion::MOTION_FIXED;
	ci.m_position = position;
	ci.m_qualityType = HK_COLLIDABLE_QUALITY_FIXED;  //floor shouldn't move
	ci.m_restitution=1.0;
	ci.m_friction=0.8;

	hkpRigidBody* floor1=new hkpRigidBody( ci );
	m_physics->GetPhysicsWorld()->addEntity( floor1 );
	floor1->removeReference(); 
	shape->removeReference();

	Ogre::MeshPtr p =Ogre::MeshManager::getSingleton().createPlane("GroundPlane", 
		Ogre::ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME, 
		Ogre::Plane(Ogre::Vector3(0.0,1.0,0.0),
			Ogre::Vector3(position(0),position(1),position(2)))
		,1000,1000,20,20,true, 1,1.0f,1.0f,Ogre::Vector3::UNIT_X);

	Ogre::SceneNode* planeNode = mSceneMgr->getRootSceneNode()->createChildSceneNode();
    Ogre::Entity* entGround = mSceneMgr->createEntity("Viewer_ZXPlane","GroundPlane");
	entGround->setMaterialName("Examples/Rockwall");
    entGround->setCastShadows(false);
	
	planeNode->attachObject(entGround);

	//initialize the ray for the ray casting
	mRayScnQuery = mSceneMgr->createRayQuery(Ogre::Ray());

	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//										Game Entity Initialisation									  //
	////////////////////////////////////////////////////////////////////////////////////////////////////////
	//The unique ID generator instance
	m_uniqueIDGenerator = GameUtilities::UniqueIDGenerator::getInstance();
	//The level instance
	m_level = GameUtilities::Level::getInstance(mSceneMgr, m_physics->GetPhysicsWorld());
	m_level->createLevel3();
	m_catapult = new GameEntities::Catapult(mSceneMgr,m_physics->GetPhysicsWorld(),Ogre::Vector3(-300,30,0));

	soundMan = new SoundManager();
}

bool RWMP5::frameRenderingQueued(const Ogre::FrameEvent& arg)
{
	//we want to run everything in the previous frameRenderingQueued call
	//but we also want to do something afterwards, so lets  start off with this
	if(!BaseApplication::frameRenderingQueued(arg))
	{
		return false;
	}
	// TODO: This timestep will have to be tweaked to work consistently on different platforms.
	//Update the physics world
	m_physics->Simulate(arg.timeSinceLastFrame); 
	//if the bird has been created, update the bird
	if(m_bomberBird != NULL)
	{
		updateBird(MAT_BIRDONE,arg.timeSinceLastFrame);
	}
	else if(m_assaultBird != NULL)
	{
		updateBird(MAT_BIRDFOUR,arg.timeSinceLastFrame);
	}
	else if(m_ghostBird != NULL)
	{
		updateBird(MAT_BIRDTWO,arg.timeSinceLastFrame);
	}
	else if(m_momBird != NULL)
	{
		updateBird(MAT_BIRDTHREE,arg.timeSinceLastFrame);
	}

	// Update the level.
	m_level->Update(arg.timeSinceLastFrame );
	// Update the catapult
	m_catapult->update();

	//update the launch pad position if the launch pad is being draged
	if(m_catapult->getIsDragPad())
	{
		m_catapult->getLaunchPad()->getBody()->setPosition(hkVector4(Mouse2DPos.x,Mouse2DPos.y,0));
	}
	m_catapult->getLaunchPad()->getBody()->setRotation(hkQuaternion(hkVector4(1,0,0),0));

	soundMan->update();

	mDetailsPanel->setParamValue(0, "");
	mDetailsPanel->setParamValue(1, "BomberBird");
	mDetailsPanel->setParamValue(2, "GhostBird");
	mDetailsPanel->setParamValue(3, "MomBird");
	mDetailsPanel->setParamValue(4, "AssaultBird");
	mDetailsPanel->setParamValue(5, "");
	mDetailsPanel->setParamValue(6, "");
	mDetailsPanel->setParamValue(7, "Space");

	mGhostBirdDetailsPanel->setParamValue(1, "Ice");
	mGhostBirdDetailsPanel->setParamValue(2, "Stone");
	mGhostBirdDetailsPanel->setParamValue(3, "Wood");
	return true;
}

bool RWMP5::mouseMoved(const OIS::MouseEvent& arg)
{
	mTrayMgr->injectMouseMove(arg);
	//mCameraMan->injectMouseMove(arg);
	if(m_mouseLeftDown)
	{
		//create a raycast straight out from the camera at the mouse's location
		Ogre::Ray mouseRay = mCamera->getCameraToViewportRay(arg.state.X.abs/float(arg.state.width), arg.state.Y.abs/float(arg.state.height));
		mRayScnQuery->setRay(mouseRay);
		mRayScnQuery->setSortByDistance(true);	//world geometry is at the end of the list if we sort it, so lets not do that
		Ogre::RaySceneQueryResult& result = mRayScnQuery->execute();
		Ogre::RaySceneQueryResult::iterator iter = result.begin();
 
		//check to see if the mouse is pointing at the world and put our current object at that location
		for(iter; iter != result.end(); iter++)
		{
			if(iter->movable && iter->movable->getName().substr(0, 5) == "Norma")
			{
				Mouse2DPos = mouseRay*iter->distance;
				m_catapult->setIsDragPad(true);
				soundMan->playStretch();
				break;
			}
		}
	}
	return true;
}

bool RWMP5::mousePressed(const OIS::MouseEvent& arg, OIS::MouseButtonID id)
{
	if(id==OIS::MB_Left){
		m_mouseLeftDown = true;
	}
	return true;
}

bool RWMP5::mouseReleased(const OIS::MouseEvent& arg, OIS::MouseButtonID id)
{
	if(id==OIS::MB_Left){
		m_mouseLeftDown = false;
		if(m_catapult->getIsDragPad() && m_currentBirdBody != NULL)
		{
			m_catapult->setIsDragPad(false);
			m_currentBirdBody->setIsAttached(false);
			m_catapult->launchBird();
			soundMan->playShot();
		}
	}
	return true;
}

bool RWMP5::keyPressed( const OIS::KeyEvent &arg )
{

	if(arg.key == OIS::KC_SPACE)
	{
		if(m_bomberBird != NULL)
			m_bomberBird->dropBomb();
		else if(m_momBird != NULL)
		{
			m_momBird->useAbility();
			soundMan->playBabyLaunch();
		}
		else if(m_assaultBird != NULL)
			m_assaultBird->shoot();
	}
	else if (arg.key == OIS::KC_ESCAPE)
	{
		mShutDown = true;
	}
	else if( arg.key == OIS::KC_1)
	{
		createBird(MAT_BIRDONE);
		soundMan->playBirdSelected();
	}
	else if( arg.key == OIS::KC_2)
	{
		createBird(MAT_BIRDTWO);
		soundMan->playBirdSelected();
	}
	else if( arg.key == OIS::KC_3)
	{
		createBird(MAT_BIRDTHREE);
		soundMan->playBirdSelected();
	}
	else if( arg.key == OIS::KC_4)
	{
		createBird(MAT_BIRDFOUR);
		soundMan->playBirdSelected();
	}

	else if( arg.key == OIS :: KC_7 )
	{
		if(m_ghostBird != NULL)
			m_ghostBird->useAbility( 1 );
	}
	else if( arg.key == OIS :: KC_8 )
	{
		if(m_ghostBird != NULL)
			m_ghostBird->useAbility( 2 );
	}
	else if( arg.key == OIS :: KC_9 )
	{
		if(m_ghostBird != NULL)
			m_ghostBird->useAbility( 3 );
	}
	mCameraMan->injectKeyDown(arg);
	return true;
}

void RWMP5::cleanAllBirds()
{
	if(m_bomberBird!=NULL)
	{
		m_catapult->launchBird();
		//need to check if the bird has already been deletedted or not
		//because the object will be automatically deleted if it goes
		//out of the physical world
		if(!m_bomberBird->getIsDeleted())
			m_bomberBird->deleteObject();
		m_bomberBird=NULL;
		m_currentBirdBody = NULL;
	}
	else if(m_ghostBird!=NULL)
	{
		m_catapult->launchBird();
		//need to check if the bird has already been deletedted or not
		//because the object will be automatically deleted if it goes
		//out of the physical world
		if(!m_ghostBird->getIsDeleted())
			m_ghostBird->deleteObject();
		m_ghostBird=NULL;
		m_currentBirdBody = NULL;
	}
	else if(m_momBird!=NULL)
	{
		m_catapult->launchBird();
		//delete the baby birds
		if(m_momBird->abilityUsed)
			m_momBird->deleteAllBabyBirds();
		//need to check if the bird has already been deletedted or not
		//because the object will be automatically deleted if it goes
		//out of the physical world
		if(!m_momBird->getIsDeleted())
			m_momBird->deleteObject();
		m_momBird=NULL;
		m_currentBirdBody = NULL;
	}
	else if(m_assaultBird!=NULL)
	{
		m_catapult->launchBird();
		//need to check if the bird has already been deletedted or not
		//because the object will be automatically deleted if it goes
		//out of the physical world
		if(!m_assaultBird->getIsDeleted())
			m_assaultBird->deleteObject();
		m_assaultBird=NULL;
		m_currentBirdBody = NULL;
	}
}

void RWMP5::createBird(EntityType type)
{
	Ogre::Vector3 pos;
	pos.x = m_catapult->getLaunchPad()->getBody()->getPosition()(0);
	pos.y = m_catapult->getLaunchPad()->getBody()->getPosition()(1);
	pos.z = m_catapult->getLaunchPad()->getBody()->getPosition()(2);
	cleanAllBirds();
	switch(type)
	{
	case MAT_BIRDONE:
		if(m_bomberBird == NULL)
		{
			m_bomberBird = new GameEntities::BomberBird(mSceneMgr,m_physics->GetPhysicsWorld(),m_uniqueIDGenerator->getNewID(),pos,5,5000,sphereInfo,MAT_BIRDONE);
			m_currentBirdBody = m_bomberBird;
			filter->disableCollisionsBetween(m_catapult->getLaunchPad()->getBody(), m_bomberBird->getBody() );
			m_catapult->attachBird(m_bomberBird->getBody());
			m_bomberBird->setIsAttached(true);
		}
		break;
	case MAT_BIRDTWO:
		if(m_ghostBird == NULL)
		{
			m_ghostBird = new GameEntities::GhostBird( mSceneMgr, m_physics->GetPhysicsWorld(), m_uniqueIDGenerator->getNewID(),pos,5,5000, sphereInfo, MAT_BIRDTWO, filter,m_level->getLevelObjectList());
			m_currentBirdBody = m_ghostBird;
			filter->disableCollisionsBetween(m_catapult->getLaunchPad()->getBody(), m_ghostBird->getBody() );
			m_catapult->attachBird(m_ghostBird->getBody());
			m_ghostBird->setIsAttached(true);
		}
		break;
	case MAT_BIRDTHREE:
		if(m_momBird == NULL)
		{
			m_momBird = new GameEntities::MomBird(mSceneMgr, m_physics->GetPhysicsWorld(),m_uniqueIDGenerator->getNewID(), pos, 5, 5000, sphereInfo, MAT_BIRDTHREE);
			m_currentBirdBody = m_momBird;
			filter->disableCollisionsBetween(m_catapult->getLaunchPad()->getBody(), m_momBird->getBody() );
			m_catapult->attachBird(m_momBird->getBody());
			m_momBird->setIsAttached(true);
		}
		break;
	case MAT_BIRDFOUR:
		if(m_assaultBird == NULL)
		{
			m_assaultBird = new GameEntities::AssaultBird(mSceneMgr, m_physics->GetPhysicsWorld(),m_uniqueIDGenerator->getNewID(), pos, 5, 5000, sphereInfo, MAT_BIRDFOUR);
			m_currentBirdBody = m_assaultBird;
			filter->disableCollisionsBetween(m_catapult->getLaunchPad()->getBody(), m_assaultBird->getBody() );
			m_catapult->attachBird(m_assaultBird->getBody());
			m_assaultBird->setIsAttached(true);
		}
		break;
	}
}

void RWMP5::updateBird(EntityType type,float timeSinceLastFrame)
{
	switch(type)
	{
	case MAT_BIRDONE:
		//update the bird
		m_bomberBird->update(timeSinceLastFrame);
		//if the bird is being attached to the launch pad
		if(m_bomberBird->getIsAttached())
		{
			//set the bird orientation to the launch pad orientation
			m_bomberBird->getBody()->setTransform
				(m_catapult->getLaunchPad()->getBody()->getTransform());
		}
		break;
	case MAT_BIRDTWO:
		m_ghostBird->update();
		if(m_ghostBird->getIsAttached())
		{
			m_ghostBird->getBody()->setTransform
				(m_catapult->getLaunchPad()->getBody()->getTransform());
		}
		break;
	case MAT_BIRDTHREE:
		m_momBird->update();
		if(m_momBird->getIsAttached())
		{
			m_momBird->getBody()->setTransform
				(m_catapult->getLaunchPad()->getBody()->getTransform());
		}
		break;
	case MAT_BIRDFOUR:
		m_assaultBird->update();
		if(m_assaultBird->getIsAttached())
		{
			m_assaultBird->getBody()->setTransform
				(m_catapult->getLaunchPad()->getBody()->getTransform());
		}
		break;
	}
}

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
#define WIN32_LEAN_AND_MEAN
#include "windows.h"
#endif

#ifdef __cplusplus
extern "C" {
#endif

#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
    INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
    int main(int argc, char *argv[])
#endif
    {
        // Create application object
        RWMP5 app;

        try {
            app.go();
        } catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
            MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
            std::cerr << "An exception has occured: " <<
                e.getFullDescription().c_str() << std::endl;
#endif
        }

        return 0;
    }

#ifdef __cplusplus
}
#endif
